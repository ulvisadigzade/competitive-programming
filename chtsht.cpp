/*
When to use BFS:

shortest path in unweighted graph

check bipartite

connected components

flood fill

When to use DFS:

check connectivity

subtree computation

detect cycles in undirected graph

When to use Dijkstra:

graph with weights ≥ 0

When to use LCA:

tree

distance between nodes

k-th ancestor

queries on paths

When to use Fenwick:

prefix sums

count frequencies

updates + queries fast

When to use Segment tree:

RMQ / range max/min/sum with updates

complex range ops

When to use DP:

constraints: n ≤ ~2000

or states fit DP

or problem says “maximize something with choices”

When to use KMP/Z:

string pattern in string

prefix/suffix logic

periodicity

longest border

When to use Hashing:

compare substrings fast

palindrome check

LCP(L), LCP(R)

two substring equality queries
*/